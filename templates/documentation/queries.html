{% extends "documentation/index.html" %}

{% block title %}Documentation | Making Queries{% endblock %}

{% block style-before %}
    <link type="text/css" rel="stylesheet" href="{{ MEDIA_URL }}css/lib/prettify.css"/>
{% endblock %}

{% block script %}
    <script type="text/javascript" src="{{ MEDIA_URL }}js/lib/prettify.js"></script>
    <script type="text/javascript">
        $(document).observe("dom:loaded", function() {
            prettyPrint();
        })
    </script>
{% endblock %}

{% block content %}

    <article>
        <div class="a-content">
            <p class="lead">Making queries</p>

            <p>            
                Androrm does not only provide automatic serialization/ deserialization of your models, but also gives you the opportunity, to execute complex queries on them. The only precondition to get started is, that you added all the correct <a href="{% url documentation_relational_fields %}">relational fields</a> to your models.
            </P>
            
            <section>
                <p>
                    In the following examples, we assume to have the following two models set up: <code>Book</code> and <code>Author</code>.
                </p>
            
                <pre class="prettyprint linenums">{% include "documentation/examples/queries/models.java" %}</pre>
                
                <p>
                    Also note, that even though the <code>objects()</code> method on the <code>Model</code> class of androrm is public, it is a good choice to have all of your models implement their own version of <code>objects()</code>, that calls the one of <code>Model</code> and hands in the correct value for the class parameter.
                </p>
                
            </section>

            <hr />
            
            <section>
                <p class="lead">
                    <a name="{{ query_set.name }}" href="#{{ query_set.name }}">{{ query_set }}</a>
                </p>

                {% autoescape off %}
                    <p>
                        {{ query_set.description }}
                    </p>
                {% endautoescape %}

                <div class="function-ref">
                    {% for function in query_set.functions.all %}
                        <h4>
                            <span class="return-value">
                                {% if not function.is_constructor %}
                                    {{ function.returns }}
                                {% endif %}
                            </span>
                            {{ function }}
                        </h4>

                        {% autoescape off %}
                            <p>
                                {{ function.description }}
                            </p>
                        {% endautoescape %}

                        {% if function.params.all %}
                            <div class="param-ref">
                                {% for param in function.params.all %}
                                    <h6>{{ param.name }}</h6>

                                    {% autoescape off %}
                                        <p>
                                            {{ param.description }}
                                        </p>
                                    {% endautoescape %}
                                {% endfor %}
                            </div>
                        {% endif %}

                        {% if not forloop.last %}
                            <hr />
                        {% endif %}

                    {% endfor %}
                </div>
                
            </section>

            <hr />

            <section>
            
                <p class="lead">
                    <a name="filter_sets" href="#filter_sets">Filter</a></p>
                </p>

                <p>
                    Again, if you already worked with <a href="http://www.djangoproject.org" target="_blank">django</a> in the past, the following examples should look familiar to you. 
                </p>
                
                <p>
                    The central class, when it comes to making queries is the <code>Filter</code> class. After you instantiated it, you will be equipped with three basic methods: <code>in</code>, <code>is</code> and <code>contains</code>. Each accepting two parameters. The first paramter hereby is a <code>String</code>, that describes the field, you want to look up. The second parameter is the value this field should have. 
                </p>
                
                <section>

                    <p class="lead">
                        <a name="filter_in" href="#filter_in">in</a>
                    </p>

                    <p>
                        If you want to specify, that a field value should be contained in a list of values, than this is the operation to go for. Let's for example assume, that you want to get all books, that are either called "Awesome book" or "The boring book". First of, you have to create a list, containing all your values. After that create the <code>FilterSet</code> instance and add the list by handing it to the <code>in</code> function.
                    </p>
                    
                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/title_in.java" %}</pre>
                    
                    <p>
                        After we have set up the filter, we can then use the <code>objects(...).filter</code> method on the <code>Book</code> model, to acutally execute it. Note, how I hand in the result of <code>getApplicationContext()</code>, to get the context I need. I do this, to not accidentially leakmemory. If you want to read more on this topic, I can recommend <a href="http://android-developers.blogspot.com/2009/01/avoiding-memory-leaks.html" target="_blank">this article on the android blog</a>.
                    </p>
                
                </section>

                <hr />

                <section>

                    <p class="lead">
                        <a name="filter_is" href="#filter_is">is</a>
                    </p>

                    <p>
                        The most commonly used filter is the <code>is</code>-filter. This one let's you exactly specify, what you are looking for. For example, if we only want books with the title "Awesome book", then our code would look like this:
                    </p>
                    
                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/title_is.java" %}</pre>
                    
                </section>

                <hr />

                <section>
                    
                    <p class="lead">
                        <a name="filter_contains" href="#filter_contains">contains</a>
                    </p>

                    <p>
                        One really neat filter function, if you for example implement a keyword search is the <code>contains</code> method. This one will take a <code>String</code> and find any instance of the model, where the field value contains this string. Be <strong>careful</strong> here! This simply translates into a <code>field_name LIKE "%value%"</code> on the SQLite database and SQLite doesn't care about case at all, when it comes to <code>LIKE</code> statements. So in any case the resulting search will be <strong>case insensitive</strong>!
                    </p>
                    
                    <p>                    
                        In this example we will search for "some book" (get the joke?).
                    </p>
                    
                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/title_contains.java" %}</pre>
            
                </section>
            </section>

            <hr />

            <section>
            
                <p class="lead">
                    <a href="#relations" name="relations">Spanning relationships</a>
                </p>
                
                <p>
                    Up till now the filter functions are cool, but nothing special actually. Why? Because writing queries for these on your own wouldn't be too hard. This changes, if we take all the relations into account. What for example happens, if you want all books, that an author called "Dan Brown" wrote? This is the point, where you write your first <code>join</code>. It get's even more complicated, if you for example have suppliers, that have branches, that sell products and you only want suppliers, where some branches sell a product with a specific name. Luckily androrm helps you here. For now, we go back to our example. So, how do we get all books, that have an author who is called "Dan Brown"?
                </p>
                
                <pre class="prettyprint linenums">{% include "documentation/examples/queries/author_name_is.java" %}</pre>
                
                <p>
                    Suprised, how few changes we had to make? If you want to traverse relationships, you can do this putting two underscores between the fieldnames. This mechanism scales for any number of fields, as long as the model classes are connected with the correct relations. More information on relationship fields can be found <a href="{% url documentation_relational_fields %}">in the relational field section</a>.
                </p>
                
                <section>
                    <p class="lead">
                        <a href="#implicit_relations" name="implicit_relations">Implicit field types</a>
                    </p>
                    
                    <p>
                        Ok, what if you are more interested in getting all books, that are associated with a certain author? You can easily achieve this functionality, by just adding a <a href="{% url documentation_relational_fields %}#OneToManyField">OneToManyField</a> to the <code>Author</code> class.
                    </p>
                    
                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/author_with_o2m.java" %}</pre>
                    
                    <p>
                        This kind of field expects a <code>ForeignKeyField</code> on the target class, that points back to it. Thus androrm knows how to handle it. So, if you now want all authors, that wrote an awesome book, you do it like this:
                    </p>

                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/book_is.java" %}</pre>
            
                </section>
            </section>

            <hr />

            <section>
            
                <p class="lead">
                    <a href="#ordering" name="ordering">Ordering</a>
                </p>

                <p>
                    When you call <code>orderBy()</code> on a query set, an instance of the <code>OrderBy</code> class will be created. The columns you have specified will then be handed to it's constructor. To learn, how to get the ordering right take 5 minutes and read the following section.
                </p>
                
                <section>
                    <p class="lead">
                        <a href="#order_by" name="order_by">{{ order_by }}</a>
                    </p>

                    {% autoescape off %}
                        <p>
                            {{ order_by.description }}
                        </p>
                    {% endautoescape %}

                    <div class="function-ref">
                        {% for function in order_by.functions.all %}
                            <h4>
                                <span class="return-value">
                                    {% if not function.is_constructor %}
                                        {{ function.returns }}
                                    {% endif %}
                                </span>
                                {{ function }}
                            </h4>
                            
                            {% autoescape off %}
                                <p>
                                    {{ function.description }}
                                </p>
                            {% endautoescape %}

                            {% if function.params.all %}
                                <div class="param-ref">
                                    {% for param in function.params.all %}
                                        <h6>{{ param.name }}</h6>

                                        {% autoescape off %}
                                            <p>
                                                {{ param.description }}
                                            </p>
                                        {% endautoescape %}
                                    {% endfor %}
                                </div>
                            {% endif %}

                            {% if not forloop.last %}
                                <hr />
                            {% endif %}

                        {% endfor %}
                    </div>
                    
                    <hr />

                    <p>                    
                        In the next example, we will get all books of an author, ordered by their title. Also we don't want them ordered ascending, but rather descending. 
                    </p>
                    
                    <pre class="prettyprint linenums">{% include "documentation/examples/queries/ordering.java" %}</pre>
                    
                    <p>
                        You could have also first applied a filter to the books query set, that would restrict the output further. Note that with query sets you have full power over the query at any time. 
                    </p>
                </section>
            
            </section>

            <hr />
            
            <p>            
                In this section you learned, how to use the <code>objects</code> method, to construct complex queries and to limit the results by utilizing the <code>Filter</code> class. You now also know, that you can easily span relationships, by only providing the correct field names. Now go and try it yourself and if you find any bugs, report them!
            </p>
            

        </div>
    </article>
    
{% endblock %}

{% block menu_content %}
    <li><a href="{% url documentation_index %}">Documentation</a></li>
    <ul>
        <li>Making Queries</li>
        <ul>
            {% for category in categories %}
                <li><a href="{{ category.url }}">{{ category.name }}</a></li>
                {% if category.category_set.all %}
                    <ul>
                        {% for subcategory in category.category_set.all %}
                            <li><a href="{{ subcategory.url }}">{{ subcategory.name }}</a></li>
                        {% endfor %}
                    </ul>
                {% endif %}
            {% endfor %}
        </ul>
    </ul>
{% endblock %}